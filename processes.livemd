<!-- livebook:{"persist_outputs":true} -->

# Processes

## Process defination

An Erlang process is very similar to an OS process. It has its own address space, it can communicate with other processes through signals and messages, and the execution is controlled by a preemptive scheduler.

A process is an isolated entity where code execution occurs. A process protects your system from errors in your code by isolating the effect of the error to the process executing the faulty code.

Elixir’s processes should not be confused with operating system processes. Processes in Elixir are extremely lightweight in terms of memory and CPU (even compared to threads as used in many other programming languages). Because of this, it is not uncommon to have tens or even hundreds of thousands of processes running simultaneously.

## Process introspection

Check processes we have in a running system: `:shell_default.i`

You might notice that many processes have a heap size of 233, that is because it is the default starting heap size of a process.

if there is a large number for the heap size, then the process uses a lot of memory and if there is a large number for the reductions then the process has executed a lot of code.

Get lot more infor about a process using `Process.info/1`

```elixir
Process.whereis(:code_server)

pid = Process.whereis(:code_server)

Process.info(pid)
```

<!-- livebook:{"output":true} -->

```
[
  registered_name: :code_server,
  current_function: {:code_server, :loop, 1},
  initial_call: {:erlang, :apply, 2},
  status: :waiting,
  message_queue_len: 0,
  links: [#PID<0.49.0>],
  dictionary: [],
  trap_exit: true,
  error_handler: :error_handler,
  priority: :normal,
  group_leader: #PID<0.46.0>,
  total_heap_size: 53194,
  heap_size: 6772,
  stack_size: 4,
  reductions: 169124,
  garbage_collection: [
    max_heap_size: %{error_logger: true, kill: true, size: 0},
    min_bin_vheap_size: 46422,
    min_heap_size: 233,
    fullsweep_after: 65535,
    minor_gcs: 67
  ],
  suspending: []
]
```

[Process.info/2](http://Process.info/2) can be used to view additional info like backtrace `Process.info(pid, :backtrace)`

The observer is also a great tool to observe processes, we will look into it in greater details later

## Process Internals

A process is basically four blocks of memory: a *stack*, a *heap*, a *message area*, and the *Process Control Block*(*the PCB*).

The stack is used for keeping track of program execution by storing return addresses, for passing arguments to functions, and for keeping local variables. Larger structures, such as lists and tuples are stored on the heap.

The *message area*, also called *the mailbox*, is used to store messages sent to the process from other processes. The process control block is used to keep track of the state of the process.

The stack, the heap, and the mailbox are all dynamically allocated and can grow and shrink as needed. PCB on the other hand is statically allocated and contains a number of fields that controls the process.

(in the first version of Erlang there was no parallelism and there could only be one process running at the time. In that version the sending process could write data directly on the receiving process' heap. With multi-core systems we use locks and queues to manage message copying accross process heaps. but this is out of scope to learn more check [this](https://blog.stenmans.org/theBeamBook/#_sending_messages_in_parallel))

Process communication is done through message passing. A process send is implemented so that a sending process copies the message from its own heap to the mailbox of the receiving process. In some cases(is suspended and no other process is trying to send a message) the message is directly copied to the receivers mailbox while in other cases message will end up in an `m-buf` After a GC the message will be moved into the heap. For more details check [here](https://blog.stenmans.org/theBeamBook/#_the_process_of_sending_a_message_to_a_process). m-bufs are varying number of heap fragments, a process can have multiple such m-bufs.

With the new *message_queue_data*
 flag introduced in Erlang 19 you can trade memory for execution time in a new way. If the receiving process is overloaded and holding on to the `main lock`
, it might be a good strategy to use the *off_heap*
 allocation in order to let the sending process quickly dump the message in an `m-buf`

## Process Dictionary

There is actually one more memory area in a process where Erlang terms can be stored, the *Process Dictionary*.

The *Process Dictionary* (PD) is a process local key-value store. One advantage with this is that all keys and values are stored on the heap and there is no copying as with send or an ETS table.

([ETS](https://elixirschool.com/en/lessons/storage/ets#overview-0) or Erlang Term Storage is a in-memory store for Elixir and Erlang objects that comes included. ETS is capable of storing large amounts of data and offers constant time data access. Tables in ETS are created and owned by individual processes. When an owner process terminates, its tables are destroyed)

```elixir
# Stores the given key-value pair in the process dictionary.
Process.put(:count, 1)
Process.put(:locale, "en")
```

<!-- livebook:{"output":true} -->

```
nil
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# Returns the value for the given key in the process dictionary
Process.get(:count)
```

<!-- livebook:{"output":true} -->

```
1
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# Returns all keys in the process dictionary
Process.get_keys()
```

<!-- livebook:{"output":true} -->

```
[:locale, :count, :evaluator_info, :"$initial_call", :"$ancestors", :ebin_path,
 :elixir_checker_info]
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# Deletes the given key from the process dictionary
Process.delete(:count)
```

<!-- livebook:{"output":true} -->

```
1
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# Returns all key-value pairs in the process dictionary.
Process.get()
```

<!-- livebook:{"output":true} -->

```
[
  locale: "en",
  evaluator_info: %{
    contexts: %{
      "2bqi3rucsgc3mkjq6nczcjh55wiktr5x" => {"qhvcikxogwjba6oeaeplktszcmhe26oa",
       #Macro.Env<
         aliases: [],
         context: nil,
         context_modules: [],
         file: "c:/Users/arpan/Documents/dev/async-elixir/processes.livemd#cell:2bqi3rucsgc3mkjq6nczcjh55wiktr5x",
         function: nil,
         functions: [
           {Kernel,
            [
              !=: 2,
              !==: 2,
              *: 2,
              **: 2,
              +: 1,
              +: 2,
              ++: 2,
              -: 1,
              -: 2,
              --: 2,
              /: 2,
              <: 2,
              <=: 2,
              ==: 2,
              ===: 2,
              =~: 2,
              >: 2,
              >=: 2,
              abs: 1,
              apply: 2,
              apply: 3,
              binary_part: 3,
              binary_slice: 2,
              binary_slice: 3,
              bit_size: 1,
              byte_size: 1,
              ceil: 1,
              div: 2,
              elem: 2,
              exit: 1,
              floor: 1,
              function_exported?: 3,
              get_and_update_in: 3,
              get_in: 2,
              hd: 1,
              ...
            ]}
         ],
         lexical_tracker: nil,
         line: 1,
         macro_aliases: [],
         macros: [
           {Kernel,
            [
              !: 1,
              &&: 2,
              ..: 0,
              ..: 2,
              ..//: 3,
              <>: 2,
              @: 1,
              alias!: 1,
              and: 2,
              binding: 0,
              binding: 1,
              dbg: 0,
              dbg: 1,
              dbg: 2,
              def: 1,
              def: 2,
              defdelegate: 2,
              defexception: 1,
              defguard: 1,
              defguardp: 1,
              defimpl: 2,
              defimpl: 3,
              defmacro: 1,
              defmacro: 2,
              defmacrop: 1,
              defmacrop: 2,
              defmodule: 2,
              defoverridable: 1,
              defp: 1,
              defp: 2,
              defprotocol: 2,
              ...
            ]}
         ],
         module: nil,
         requires: [],
         ...
       >},
      "2moblbvocodre6c5w5pkveptvo43s735" => {"saysuojpooo4vx6pb6nbe3iifzqm5ddv",
       #Macro.Env<
         aliases: [],
         context: nil,
         context_modules: [],
         file: "c:/Users/arpan/Documents/dev/async-elixir/processes.livemd#cell:2moblbvocodre6c5w5pkveptvo43s735",
         function: nil,
         functions: [
           {Kernel,
            [
              !=: 2,
              !==: 2,
              *: 2,
              **: 2,
              +: 1,
              +: 2,
              ++: 2,
              -: 1,
              -: 2,
              --: 2,
              /: 2,
              <: 2,
              <=: 2,
              ==: 2,
              ===: 2,
              =~: 2,
              >: 2,
              >=: 2,
              abs: 1,
              apply: 2,
              apply: 3,
              binary_part: 3,
              binary_slice: 2,
              binary_slice: 3,
              bit_size: 1,
              byte_size: 1,
              ceil: 1,
              div: 2,
              elem: 2,
              exit: 1,
              floor: 1,
              function_exported?: 3,
              get_and_update_in: 3,
              get_in: 2,
              ...
            ]}
         ],
         lexical_tracker: nil,
         line: 1,
         macro_aliases: [],
         macros: [
           {Kernel,
            [
              !: 1,
              &&: 2,
              ..: 0,
              ..: 2,
              ..//: 3,
              <>: 2,
              @: 1,
              alias!: 1,
              and: 2,
              binding: 0,
              binding: 1,
              dbg: 0,
              dbg: 1,
              dbg: 2,
              def: 1,
              def: 2,
              defdelegate: 2,
              defexception: 1,
              defguard: 1,
              defguardp: 1,
              defimpl: 2,
              defimpl: 3,
              defmacro: 1,
              defmacro: 2,
              defmacrop: 1,
              defmacrop: 2,
              defmodule: 2,
              defoverridable: 1,
              defp: 1,
              defp: 2,
              ...
            ]}
         ],
         module: nil,
         requires: [],
         ...
       >},
      "6ka67jlkocayvfotdhhtsiwriawjc3lr" => {"5hwyi3ndw6vtrantrhi2z7qzcx4viw5g",
       #Macro.Env<
         aliases: [],
         context: nil,
         context_modules: [],
         file: "c:/Users/arpan/Documents/dev/async-elixir/processes.livemd#cell:6ka67jlkocayvfotdhhtsiwriawjc3lr",
         function: nil,
         functions: [
           {Kernel,
            [
              !=: 2,
              !==: 2,
              *: 2,
              **: 2,
              +: 1,
              +: 2,
              ++: 2,
              -: 1,
              -: 2,
              --: 2,
              /: 2,
              <: 2,
              <=: 2,
              ==: 2,
              ===: 2,
              =~: 2,
              >: 2,
              >=: 2,
              abs: 1,
              apply: 2,
              apply: 3,
              binary_part: 3,
              binary_slice: 2,
              binary_slice: 3,
              bit_size: 1,
              byte_size: 1,
              ceil: 1,
              div: 2,
              elem: 2,
              exit: 1,
              floor: 1,
              function_exported?: 3,
              get_and_update_in: 3,
              ...
            ]}
         ],
         lexical_tracker: nil,
         line: 1,
         macro_aliases: [],
         macros: [
           {Kernel,
            [
              !: 1,
              &&: 2,
              ..: 0,
              ..: 2,
              ..//: 3,
              <>: 2,
              @: 1,
              alias!: 1,
              and: 2,
              binding: 0,
              binding: 1,
              dbg: 0,
              dbg: 1,
              dbg: 2,
              def: 1,
              def: 2,
              defdelegate: 2,
              defexception: 1,
              defguard: 1,
              defguardp: 1,
              defimpl: 2,
              defimpl: 3,
              defmacro: 1,
              defmacro: 2,
              defmacrop: 1,
              defmacrop: 2,
              defmodule: 2,
              defoverridable: 1,
              defp: 1,
              ...
            ]}
         ],
         module: nil,
         requires: [],
         ...
       >},
      "fglpgxu4t2b3hhfgn7l2dd37kfmtktdc" => {"d4xblzuwtyfsxhadmcnpictcef4ruy27",
       #Macro.Env<
         aliases: [],
         context: nil,
         context_modules: [],
         file: "c:/Users/arpan/Documents/dev/async-elixir/processes.livemd#cell:fglpgxu4t2b3hhfgn7l2dd37kfmtktdc",
         function: nil,
         functions: [
           {Kernel,
            [
              !=: 2,
              !==: 2,
              *: 2,
              **: 2,
              +: 1,
              +: 2,
              ++: 2,
              -: 1,
              -: 2,
              --: 2,
              /: 2,
              <: 2,
              <=: 2,
              ==: 2,
              ===: 2,
              =~: 2,
              >: 2,
              >=: 2,
              abs: 1,
              apply: 2,
              apply: 3,
              binary_part: 3,
              binary_slice: 2,
              binary_slice: 3,
              bit_size: 1,
              byte_size: 1,
              ceil: 1,
              div: 2,
              elem: 2,
              exit: 1,
              floor: 1,
              function_exported?: 3,
              ...
            ]}
         ],
         lexical_tracker: nil,
         line: 1,
         macro_aliases: [],
         macros: [
           {Kernel,
            [
              !: 1,
              &&: 2,
              ..: 0,
              ..: 2,
              ..//: 3,
              <>: 2,
              @: 1,
              alias!: 1,
              and: 2,
              binding: 0,
              binding: 1,
              dbg: 0,
              dbg: 1,
              dbg: 2,
              def: 1,
              def: 2,
              defdelegate: 2,
              defexception: 1,
              defguard: 1,
              defguardp: 1,
              defimpl: 2,
              defimpl: 3,
              defmacro: 1,
              defmacro: 2,
              defmacrop: 1,
              defmacrop: 2,
              defmodule: 2,
              defoverridable: 1,
              ...
            ]}
         ],
         module: nil,
         requires: [],
         ...
       >},
      "setup" => {"isxyuv3t7sjb23fsxz5ucopdqmwsaa7e",
       #Macro.Env<
         aliases: [],
         context: nil,
         context_modules: [],
         file: "c:/Users/arpan/Documents/dev/async-elixir/processes.livemd#cell:setup",
         function: nil,
         functions: [
           {Kernel,
            [
              !=: 2,
              !==: 2,
              *: 2,
              **: 2,
              +: 1,
              +: 2,
              ++: 2,
              -: 1,
              -: 2,
              --: 2,
              /: 2,
              <: 2,
              <=: 2,
              ==: 2,
              ===: 2,
              =~: 2,
              >: 2,
              >=: 2,
              abs: 1,
              apply: 2,
              apply: 3,
              binary_part: 3,
              binary_slice: 2,
              binary_slice: 3,
              bit_size: 1,
              byte_size: 1,
              ceil: 1,
              div: 2,
              elem: 2,
              exit: 1,
              floor: 1,
              ...
            ]}
         ],
         lexical_tracker: nil,
         line: 1,
         macro_aliases: [],
         macros: [
           {Kernel,
            [
              !: 1,
              &&: 2,
              ..: 0,
              ..: 2,
              ..//: 3,
              <>: 2,
              @: 1,
              alias!: 1,
              and: 2,
              binding: 0,
              binding: 1,
              dbg: 0,
              dbg: 1,
              dbg: 2,
              def: 1,
              def: 2,
              defdelegate: 2,
              defexception: 1,
              defguard: 1,
              defguardp: 1,
              defimpl: 2,
              defimpl: 3,
              defmacro: 1,
              defmacro: 2,
              defmacrop: 1,
              defmacrop: 2,
              defmodule: 2,
              ...
            ]}
         ],
         module: nil,
         requires: [],
         ...
       >},
      "yk6emsxpmclz2dkkpjmp2bi65v2hn3mi" => {"2mnanzqxewp2pvi3kalt2ndflkepqhwq",
       #Macro.Env<
         aliases: [],
         context: nil,
         context_modules: [],
         file: "c:/Users/arpan/Documents/dev/async-elixir/processes.livemd#cell:yk6emsxpmclz2dkkpjmp2bi65v2hn3mi",
         function: nil,
         functions: [
           {Kernel,
            [
              !=: 2,
              !==: 2,
              *: 2,
              **: 2,
              +: 1,
              +: 2,
              ++: 2,
              -: 1,
              -: 2,
              --: 2,
              /: 2,
              <: 2,
              <=: 2,
              ==: 2,
              ===: 2,
              =~: 2,
              >: 2,
              >=: 2,
              abs: 1,
              apply: 2,
              apply: 3,
              binary_part: 3,
              binary_slice: 2,
              binary_slice: 3,
              bit_size: 1,
              byte_size: 1,
              ceil: 1,
              div: 2,
              elem: 2,
              exit: 1,
              ...
            ]}
         ],
         lexical_tracker: nil,
         line: 1,
         macro_aliases: [],
         macros: [
           {Kernel,
            [
              !: 1,
              &&: 2,
              ..: 0,
              ..: 2,
              ..//: 3,
              <>: 2,
              @: 1,
              alias!: 1,
              and: 2,
              binding: 0,
              binding: 1,
              dbg: 0,
              dbg: 1,
              dbg: 2,
              def: 1,
              def: 2,
              defdelegate: 2,
              defexception: 1,
              defguard: 1,
              defguardp: 1,
              defimpl: 2,
              defimpl: 3,
              defmacro: 1,
              defmacro: 2,
              defmacrop: 1,
              defmacrop: 2,
              ...
            ]}
         ],
         module: nil,
         requires: [],
         ...
       >}
    },
    initial_context: {"ty2thf3ovewmewpmoenmqsb35jg6b7nx",
     #Macro.Env<
       aliases: [],
       context: nil,
       context_modules: [],
       file: "nofile",
       function: nil,
       functions: [
         {Kernel,
          [
            !=: 2,
            !==: 2,
            *: 2,
            **: 2,
            +: 1,
            +: 2,
            ++: 2,
            -: 1,
            -: 2,
            --: 2,
            /: 2,
            <: 2,
            <=: 2,
            ==: 2,
            ===: 2,
            =~: 2,
            >: 2,
            >=: 2,
            abs: 1,
            apply: 2,
            apply: 3,
            binary_part: 3,
            binary_slice: 2,
            binary_slice: 3,
            bit_size: 1,
            byte_size: 1,
            ceil: 1,
            div: 2,
            elem: 2,
            exit: 1,
            floor: 1,
            function_exported?: 3,
            get_and_update_in: 3,
            get_in: 2,
            hd: 1,
            ...
          ]}
       ],
       lexical_tracker: nil,
       line: 1,
       macro_aliases: [],
       macros: [
         {Kernel,
          [
            !: 1,
            &&: 2,
            ..: 0,
            ..: 2,
            ..//: 3,
            <>: 2,
            @: 1,
            alias!: 1,
            and: 2,
            binding: 0,
            binding: 1,
            dbg: 0,
            dbg: 1,
            dbg: 2,
            def: 1,
            def: 2,
            defdelegate: 2,
            defexception: 1,
            defguard: 1,
            defguardp: 1,
            defimpl: 2,
            defimpl: 3,
            defmacro: 1,
            defmacro: 2,
            defmacrop: 1,
            defmacrop: 2,
            defmodule: 2,
            defoverridable: 1,
            defp: 1,
            defp: 2,
            defprotocol: 2,
            ...
          ]}
       ],
       module: nil,
       requires: [Application, Kernel, Kernel.Typespec],
       ...
     >}
  },
  "$initial_call": {Livebook.Runtime.Evaluator, :init, 1},
  "$ancestors": [#PID<0.131.0>, #PID<0.130.0>, #PID<0.126.0>, Livebook.Runtime.ErlDist.NodeManager,
   #PID<0.124.0>],
  ebin_path: "C:\\Users\\arpan\\AppData\\Local\\Temp/livebook_runtime/dewsqwgsiwm2syc6qxowlsboh2dlx6ij/ebin",
  elixir_checker_info: {#PID<0.136.0>, nil}
]
```

## Process Basics

The most fundamental way to create processes in Elixir is by using the [spawn/1](https://hexdocs.pm/elixir/1.12/Kernel.html#spawn/1), [receive/1](https://hexdocs.pm/elixir/1.12/Kernel.SpecialForms.html#receive/1), and [send/2](https://hexdocs.pm/elixir/1.12/Kernel.html#send/2) functions. They enable us to spawn a process, wait for messages, and send messages to a process, respectively.

Many higher-level abstractions, such as Task, GenServer, and Agent, are built on top of these primitive functions.

These functions are part of the [Kernel](https://hexdocs.pm/elixir/1.12/Kernel.html) module and are automatically imported, allowing us to call them directly without needing to use the Kernel. prefix.

Let's take a look at some examples of their usage...

```elixir
# Spawn a process, by passing it a function to execute.
# spawn/1 returns the pid (process identifier) of the spawed process
pid = spawn(fn -> IO.puts("Hello world") end)

# Once the process has finished excuting it will exit
Process.alive?(pid) |> IO.inspect()

# Sleep for 100ms to wait for process to exit
:timer.sleep(100)

Process.alive?(pid)
```

<!-- livebook:{"output":true} -->

```
true
Hello world
```

<!-- livebook:{"output":true} -->

```
false
```

To exchange messages between processes in Elixir, you can use the send/2 and receive/1 functions.

When a process uses send/2 to send a message, it doesn't block - instead, the message is placed in the recipient's mailbox, and the sending process continues.

On the other hand, when a process uses receive/1, it blocks until a matching message is found in its mailbox. The receive/1 function searches the mailbox for a message that matches any of the given patterns.

receive/1 supports guards and multiple clauses, such as case/2.

Let's look at an example of a process sending a message to itself.

```elixir
# Get the pid of the current process
self_pid = self()

# Send a message to the current process
send(self_pid, :ping)

# Check messages in mailbox without consuming them
Process.info(self_pid, :messages) |> IO.inspect(label: "Messages in mailbox")

# Recieve the message waiting in mailbox
receive do
  :ping -> IO.puts(:pong)
end

# Check messages in mailbox again
Process.info(self_pid, :messages) |> IO.inspect(label: "Messages in mailbox")
```

<!-- livebook:{"output":true} -->

```
Messages in mailbox: {:messages, [:ping]}
pong
Messages in mailbox: {:messages, []}
```

<!-- livebook:{"output":true} -->

```
{:messages, []}
```

An optional after clause can be given in case the message was not received after the given timeout period, specified in milliseconds.
(If timeout `0` is given then the message is expected to be already present in the mailbox.)

```elixir
receive do
  {:message, message} when message in [:start, :stop] -> IO.puts(message)
  _ -> IO.puts(:stderr, "Unexpected message received")
after
  1000 -> IO.puts(:stderr, "Timeout, no message in 1 seconds")
end
```

<!-- livebook:{"output":true} -->

```
Timeout, no message in 1 seconds
```

<!-- livebook:{"output":true} -->

```
:ok
```

In the elixir IEx shell, we have a helper function [flush/0](https://hexdocs.pm/iex/main/IEx.Helpers.html#flush/0) that flushes or consumes and prints all the messages in the mailbox of the shell process.

```elixir
send(self(), :hello)

Process.info(self_pid, :messages) |> IO.inspect(label: "Messages in mailbox before flush")

# In the iex shell we wont have to use the `IEx.Helpers,` prefix since these helpers functions are imported automatically
IEx.Helpers.flush()

Process.info(self_pid, :messages) |> IO.inspect(label: "Messages in mailbox after flush")
```

<!-- livebook:{"output":true} -->

```
Messages in mailbox before flush: {:messages, [:hello]}
:hello
Messages in mailbox after flush: {:messages, []}
```

<!-- livebook:{"output":true} -->

```
{:messages, []}
```

## Process Linking

In Elixir, when we create a process, we have the option to link it to its parent process. This means that if the child process encounters an error and fails, the parent process will be notified.

When we use the `spawn/1` function to create a process, it will not be linked to its parent process. As a result, if the child process encounters an error and fails, the parent process will not be notified.

To ensure that the parent process is notified of any errors in the child process, we can use the `spawn_link/1` function instead. This function creates a linked process, so if the child process crashes, the parent process will receive an **EXIT** signal.

To illustrate this, let's consider an example...

```elixir
unlinked_child_process = spawn(fn -> raise("BOOM! Unliked process crashed!") end)

IO.inspect(Process.info(self(), :links))

:timer.sleep(100)

IO.puts("Parent process still alive!")
```

<!-- livebook:{"output":true} -->

```
{:links, [#PID<0.131.0>]}

22:43:46.500 [error] Process #PID<0.139.0> on node :"d6frpv5e-livebook_app@Arpan-desktop" raised an exception
** (RuntimeError) BOOM! Unliked process crashed!
    c:/Users/arpan/Documents/dev/async-elixir/processes.livemd#cell:andw5ityxkx5ji7gax64vrwxrk5ngzwm:1: (file)
Parent process still alive!
```

<!-- livebook:{"output":true} -->

```
:ok
```

In the above example we can see that the parent process is still alive after the spawned process crashes. Lets see what happens if the processes were linked

```elixir
# linked_child_process = spawn_link(fn -> raise("BOOM! Linked process crashed!") end)

# IO.inspect Process.info(self(), :links)

# :timer.sleep(100)

# IO.puts "Parent process still alive!"
```

<!-- livebook:{"output":true} -->

```
nil
```

This time the print statement "Parent process still alive!" is never printed because when linked process crashes it brings down the parent process with it.

When a linked process exits gracefully with a reason `:normal` this does not lead to the parent process to crash. Any other reason other than `:normal` is considered an abnormal termination and will lead to the linked processes exiting as well.

```elixir
linked_process = spawn_link(fn -> :timer.sleep(60000) end)
Process.exit(linked_process, :normal)
:timer.sleep(100)
IO.puts(Process.alive?(linked_process))
```

<!-- livebook:{"output":true} -->

```
true
```

<!-- livebook:{"output":true} -->

```
:ok
```

Linking can also be done manually by calling `Process.link/1`, lets see a bigger example...

```elixir
defmodule LinkingProcess do
  def call do
    child_process = spawn(&recursive_link_inspectior/0)

    IO.inspect(self(), label: "Parent process PID")
    IO.inspect(child_process, label: "Child process PID")

    IO.inspect(Process.info(self(), :links), label: "Parent process links")

    send(child_process, :inspect_links)

    # Wait for the child process to print its links
    :timer.sleep(100)

    # Link the two processes
    Process.link(child_process)

    IO.inspect(Process.info(self(), :links), label: "Parent process links")

    send(child_process, :inspect_links)
  end

  defp recursive_link_inspectior do
    receive do
      :inspect_links ->
        links = Process.info(self(), :links)
        IO.inspect(links, label: "Child process links")
    end

    recursive_link_inspectior()
  end
end

LinkingProcess.call()
```

<!-- livebook:{"output":true} -->

```
Parent process PID: #PID<0.136.0>
Child process PID: #PID<0.147.0>
Parent process links: {:links, [#PID<0.140.0>, #PID<0.143.0>, #PID<0.145.0>, #PID<0.131.0>]}
Child process links: {:links, []}
Parent process links: {:links,
 [#PID<0.140.0>, #PID<0.145.0>, #PID<0.147.0>, #PID<0.143.0>, #PID<0.131.0>]}
Child process links: {:links, [#PID<0.136.0>]}
```

<!-- livebook:{"output":true} -->

```
:inspect_links
```

When a process is linked to others, a crash in that process can trigger a cascade effect, potentially causing multiple other linked processes to crash as well. For instance, imagine a scenario where five processes (P1 to P5) are linked as follows:

`P1 <-> P2 <-> P3 <-> P4 <-> P5`

If any of these processes crash, it will cause all five to fail due to their interconnectivity. For instance, if P4 crashes, it will cause P3 and P5 to crash as well. This, in turn, will lead to the failure of P2, which will ultimately cause P1 to fail as well.

It's important to remember that **process links are bidirectional**, which means that if one process fails, it will affect the other processes as well.

<!-- livebook:{"break_markdown":true} -->

### Importance of process linking

Processes and links play an important role when building fault-tolerant systems. Elixir processes are isolated and don’t share anything by default. Therefore, a failure in a process will never crash or corrupt the state of another process. Links, however, allow processes to establish a relationship in case of failure. We often link our processes to supervisors which will detect when a process dies and start a new process in its place.

While other languages would require us to catch/handle exceptions, in Elixir we are actually fine with letting processes fail because we expect supervisors to properly restart our systems. “Failing fast” (sometimes referred as “let it crash”) is a common philosophy when writing Elixir software!

<!-- livebook:{"break_markdown":true} -->

### Trapping EXITS

For some reason if we want to prevent a process from crashing when a linked process exits we can do so by trapping exit message.

Normally when a process finishes its work it implicitly calls exit(:normal) to communicate with its parent that job has been done. Every other argument to exit/1 than :normal is treated as an error.

Setting `trap_exit` to true in Elixir means that exit signals received by a process are converted into messages of the form `{'EXIT', From, Reason}`. These messages can then be received like any other message in the process's mailbox. On the other hand, if `trap_exit` is set to false, the process will exit if it receives an exit signal that is not a normal exit, and the signal will be passed on to any processes that are linked to it.

By using `trap_exit` and linking processes, we can prevent the failure of one process from causing the failure of another. This allows the linked process to handle the termination of the other process gracefully, rather than being abruptly terminated itself.

As always lets look at an example to understand this better...

```elixir
Process.flag(:trap_exit, true)

p = spawn_link(fn -> exit(:boom) end)

:timer.sleep(100)

IO.puts(Process.alive?(p))

Process.info(self_pid, :messages) |> IO.inspect(label: "Messages in mailbox")
```

<!-- livebook:{"output":true} -->

```
false
Messages in mailbox: {:messages, [{:EXIT, #PID<0.151.0>, :boom}]}
```

<!-- livebook:{"output":true} -->

```
{:messages, [{:EXIT, #PID<0.151.0>, :boom}]}
```

As we see from the print messages the linked process crashing does not lead to a crash of the parent process as it is trapping exits, instead the parent receives a message like `{:EXIT, linked_process_pid, :boom}` in its mailbox.

<!-- livebook:{"break_markdown":true} -->

It is generally recommended to avoid trapping exits as it can modify the normal behavior of processes. Instead, it is recommended to utilize monitors and supervisors to handle failures.

When a process traps exits, it becomes unresponsive to exit signals unless a kill exit reason is explicitly sent to it. Lets look at an example...

```elixir
p =
  spawn(fn ->
    Process.flag(:trap_exit, true)
    :timer.sleep(:infinity)
  end)

IO.inspect(Process.alive?(p), label: "Process alive initially")

Process.exit(p, :normal)
IO.inspect(Process.alive?(p), label: "After :normal exit signal")

Process.exit(p, :boom)
IO.inspect(Process.alive?(p), label: "After :boom exit signal")

Process.exit(p, :kill)
IO.inspect(Process.alive?(p), label: "After :kill exit signal")
```

<!-- livebook:{"output":true} -->

```
Process alive initially: true
After :normal exit signal: true
After :boom exit signal: true
After :kill exit signal: false
```

<!-- livebook:{"output":true} -->

```
false
```

## Process monitoring

Process links are bidirectional, which means that if a linked process exits, it will also bring down the current process. However, if we only want the current process to be notified when a process has exited, instead of linking, we can use monitors.

Unlike linking, monitoring is unidirectional. If there is an error in a monitored process, it does not bring down the current process. Instead, the current process is notified via a `{:DOWN, <reference>, :process, <pid>, <exit_reason>}` message.

It's worth noting that even when the monitored process exits normally, we still receive a message. In the case of process linking, a process is only notified if the linked process exits abnormally (i.e., with a reason other than :normal).

Lets look at an example of process monitoring...

```elixir
pid = spawn(fn -> :timer.sleep(10000) end)
Process.monitor(pid)
Process.exit(pid, :boom)
:timer.sleep(100)
IO.inspect(Process.info(self(), :messages))
```

<!-- livebook:{"output":true} -->

```
{:messages,
 [
   {:EXIT, #PID<0.151.0>, :boom},
   {:DOWN, #Reference<0.3427697134.1500250116.29236>, :process, #PID<0.153.0>,
    :boom}
 ]}
```

<!-- livebook:{"output":true} -->

```
{:messages,
 [
   {:EXIT, #PID<0.151.0>, :boom},
   {:DOWN, #Reference<0.3427697134.1500250116.29236>, :process, #PID<0.153.0>, :boom}
 ]}
```

You can demontior a minotred process by calling `Process.demonitor/3`.

## Process hibernation

We can call `Process.hibernate/3` to hibernate a process.

From the official [documentation](https://erlang.org/doc/man/erlang.html#hibernate-3)

> Puts the calling process into a **wait state** where its **memory allocation has been reduced as much as possible**. This is useful if the process does not expect to receive any messages soon. The process is awaken when a message is sent to it, and control resumes in Module:Function with the arguments specified by Args with the call stack emptied.

> In more technical terms, `erlang:hibernate/3` discards the call stack for the process, and then **garbage collects** the process. After this, all live data is in one continuous heap. The heap is then shrunken to the exact same size as the live data that it holds.

<!-- livebook:{"break_markdown":true} -->

### When is process hiberantion usefull?

Hibernation of a process can be beneficial in situations where the process should not be terminated but is not expected to receive any messages anytime soon. By hibernating the process, we can free up the memory that was allocated to the process during garbage collection and thus prevent unnecessary resource usage.

Some practical examples where hibernation can be useful include occasionally used processes that should not be dropped, as doing so may be interpreted as a network disconnection by the client. Additionally, any process that is expensive to reinitialize may also be a good candidate for hibernation.

Lets see an example...

```elixir
p1 =
  spawn(fn ->
    _big_binary = :crypto.strong_rand_bytes(1000)
    :timer.sleep(:infinity)
  end)

p2 =
  spawn(fn ->
    _big_binary = :crypto.strong_rand_bytes(1000)
    Process.hibernate(IO, :puts, ["P2 woken from hibernation"])

    # This never executes as execution resumes at the function passed to Process.hibernate/3
    :timer.sleep(:infinity)
  end)

Process.info(p1, :total_heap_size) |> IO.inspect(label: "Heap size of P1")
Process.info(p2, :total_heap_size) |> IO.inspect(label: "Heap size of P2")

# Wake p2 from hibernation by sending it a message
send(p2, :msg)
Process.alive?(p2) |> IO.inspect(label: "P2 alive")
```

<!-- livebook:{"output":true} -->

```
Heap size of P1: {:total_heap_size, 233}
Heap size of P2: {:total_heap_size, 17}
P2 alive: true
P2 woken from hibernation
```

<!-- livebook:{"output":true} -->

```
true
```

## Process naming

We can name processes and then refer to them via their registered name.

```elixir
Process.register(self(), :my_process)
Process.registered() |> IO.inspect()

send(:my_process, "Hello")
Process.info(self(), :messages) |> IO.inspect()
Process.unregister(:my_process)
Process.registered() |> IO.inspect()
```

<!-- livebook:{"output":true} -->

```
[:socket_registry, :my_process, :inet_gethost_native_sup, :erl_prim_loader,
 :kernel_safe_sup, :global_group, :auth, :application_controller, :logger,
 :elixir_sup, :logger_sup, :rex, Logger.Supervisor, :inet_gethost_native,
 :elixir_code_server, Logger.BackendSupervisor, :net_kernel, :logger_proxy,
 :kernel_sup, :user, Livebook.Runtime.ErlDist.NodeManager, :inet_db,
 :erts_code_purger, :kernel_refc, :init, :logger_handler_watcher,
 :erl_signal_server, :erl_epmd, :global_name_server, :file_server_2, Logger,
 :elixir_config, :standard_error_sup, :net_sup, :code_server, :standard_error]
{:messages,
 [
   {:EXIT, #PID<0.151.0>, :boom},
   {:DOWN, #Reference<0.3427697134.1500250116.29236>, :process, #PID<0.153.0>,
    :boom},
   "Hello"
 ]}
[:socket_registry, :inet_gethost_native_sup, :erl_prim_loader, :kernel_safe_sup,
 :global_group, :auth, :application_controller, :logger, :elixir_sup,
 :logger_sup, :rex, Logger.Supervisor, :inet_gethost_native,
 :elixir_code_server, Logger.BackendSupervisor, :net_kernel, :logger_proxy,
 :kernel_sup, :user, Livebook.Runtime.ErlDist.NodeManager, :inet_db,
 :erts_code_purger, :kernel_refc, :init, :logger_handler_watcher,
 :erl_signal_server, :erl_epmd, :global_name_server, :file_server_2, Logger,
 :elixir_config, :standard_error_sup, :net_sup, :code_server, :standard_error]
```

<!-- livebook:{"output":true} -->

```
[:socket_registry, :inet_gethost_native_sup, :erl_prim_loader, :kernel_safe_sup, :global_group,
 :auth, :application_controller, :logger, :elixir_sup, :logger_sup, :rex, Logger.Supervisor,
 :inet_gethost_native, :elixir_code_server, Logger.BackendSupervisor, :net_kernel, :logger_proxy,
 :kernel_sup, :user, Livebook.Runtime.ErlDist.NodeManager, :inet_db, :erts_code_purger,
 :kernel_refc, :init, :logger_handler_watcher, :erl_signal_server, :erl_epmd, :global_name_server,
 :file_server_2, Logger, :elixir_config, :standard_error_sup, :net_sup, :code_server,
 :standard_error]
```

## Group Leader

In Erlang, every process belongs to a process group, and each group has a group leader. The group leader is responsible for handling I/O for the processes in its group. When a process is spawned, it inherits the same group leader as its parent process. At system start-up, the init process is both its own group leader and the group leader of all processes.

The Erlang VM models I/O devices as processes, which enables different nodes in the same network to exchange file processes and read/write files between nodes. The group leader can be configured per process and is used in different situations. For example, when executing code in a remote terminal, it ensures that messages from a remote node are redirected and printed in the terminal that triggered the request.

The main responsibility of the group leader is to collect I/O output from all processes in its group and pass it to or from the underlying system. It essentially owns the standard input, standard output, and standard error channels on behalf of the group.

When a file is opened using `File.open/2`, it returns a tuple like `{:ok, io_device}`, where `io_device` is the PID of the process that handles the file. This process monitors the process that opened the file (the owner process), and if the owner process terminates, the file is closed, and the process itself terminates too.

When you call `IO.write(pid, binary)`, the IO module sends a message to the process identified by pid with the desired operation, such as :put_chars. 
The message has the following structure: `{:io_request, <pid>, <reference>, {:put_chars, :unicode, "hello"}}`.

When you write to :stdio, you are actually sending a message to the group leader, which writes to the standard-output file descriptor. 
Therefore, these three code snippets are equivalent:

```
IO.puts "hello"
IO.puts :stdio, "hello"
IO.puts Process.group_leader, "hello"
```

To understand this better let see some examples

Suppose we have two Erlang nodes named "node1" and "node2". 
You can create two `iex` shells for this like

```
iex --sname node1@localhost
iex --sname node2@localhost
```

(Note: If you want to send messages between nodes on different networks, we need to start the named nodes with a shared cookie)

If we execute the following code in the iex shell of node1:

```
Node.spawn_link(:node2@localhost, fn ->
  IO.puts("I will be executed on node2 but printed on node1 since the group leader is node1")
end)
```

The output of the IO.puts operation will be sent to the group leader, which in this case is node1. 
Therefore, the output will be printed on node1's standard output stream, even though the process that performed the operation is running on node2.

On the other hand, if we specify the device PID as the `:init` process on node2, the output will be seen on node2's standard output stream:

```
Node.spawn_link(:node2@localhost, fn ->
  init_process_pid = Process.whereis(:init)

  IO.puts(
    init_process_pid,
    "I will be executed on node2 and printed on node2 since the device ID passed was node2's init process"
  )
end)
```

Finally, we can also set the group leader of a process explicitly by calling `Process.group_leader/2`. 
In the following example, we set the group leader of the process running on node2 to node2's `:init` process:

```
Node.spawn_link(:node2@localhost, fn ->
  init_process_pid = Process.whereis(:init)
  Process.group_leader(self(), init_process_pid)

  IO.puts(
    "I will be executed on node2 and printed on node2 since the group leader is set to node2's init process"
  )
end)
```

In this case, the output of the `IO.puts` operation will be sent to node2's `:init` process, which is the new group leader of the process. 
Therefore, the output will be printed on node2's standard output stream.

## Resources

* https://elixir-lang.org/getting-started/processes.html#:~:text=In Elixir%2C all code runs,distributed and fault-tolerant programs.
* https://blog.stenmans.org/theBeamBook/#CH-Processes
* https://hexdocs.pm/elixir/1.12/Process.html
* https://eddwardo.github.io/posts/links-in-elixir/
* https://www.erlang-solutions.com/blog/understanding-processes-for-elixir-developers/
* https://elixirforum.com/t/when-is-hibernation-of-processes-useful/23181/5
* Group Leader
  * https://www.erlang.org/doc/man/erlang.html#group_leader-0
  * https://stackoverflow.com/questions/36318766/what-is-a-group-leader
  * https://rokobasilisk.gitbooks.io/elixir-getting-started/content/io_and_the_file_system/processes_and_group_leaders.html
  * https://elixirschool.com/en/lessons/advanced/otp_distribution#a-note-on-io-and-nodes-2

<!-- livebook:{"persist_outputs":true} -->

# Processes

## Process defination

An Erlang process is very similar to an OS process. It has its own address space, it can communicate with other processes through signals and messages, and the execution is controlled by a preemptive scheduler.

A process is an isolated entity where code execution occurs. A process protects your system from errors in your code by isolating the effect of the error to the process executing the faulty code.

Elixir’s processes should not be confused with operating system processes. Processes in Elixir are extremely lightweight in terms of memory and CPU (even compared to threads as used in many other programming languages). Because of this, it is not uncommon to have tens or even hundreds of thousands of processes running simultaneously.

## Process introspection

Check processes we have in a running system: `:shell_default.i`

You might notice that many processes have a heap size of 233, that is because it is the default starting heap size of a process.

if there is a large number for the heap size, then the process uses a lot of memory and if there is a large number for the reductions then the process has executed a lot of code.

Get lot more infor about a process using `Process.info/1`

```elixir
Process.whereis(:code_server)

pid = Process.whereis(:code_server)

Process.info(pid)
```

<!-- livebook:{"output":true} -->

```
[
  registered_name: :code_server,
  current_function: {:code_server, :loop, 1},
  initial_call: {:erlang, :apply, 2},
  status: :waiting,
  message_queue_len: 0,
  links: [#PID<0.49.0>],
  dictionary: [],
  trap_exit: true,
  error_handler: :error_handler,
  priority: :normal,
  group_leader: #PID<0.46.0>,
  total_heap_size: 53194,
  heap_size: 6772,
  stack_size: 4,
  reductions: 184071,
  garbage_collection: [
    max_heap_size: %{error_logger: true, kill: true, size: 0},
    min_bin_vheap_size: 46422,
    min_heap_size: 233,
    fullsweep_after: 65535,
    minor_gcs: 2
  ],
  suspending: []
]
```

[Process.info/2](http://Process.info/2) can be used to view additional info like backtrace `Process.info(pid, :backtrace)`

The observer is also a great tool to observe processes, we will look into it in greater details later

## Process Internals

A process is basically four blocks of memory: a *stack*, a *heap*, a *message area*, and the *Process Control Block*(*the PCB*).

The stack is used for keeping track of program execution by storing return addresses, for passing arguments to functions, and for keeping local variables. Larger structures, such as lists and tuples are stored on the heap.

The *message area*, also called *the mailbox*, is used to store messages sent to the process from other processes. The process control block is used to keep track of the state of the process.

The stack, the heap, and the mailbox are all dynamically allocated and can grow and shrink as needed. PCB on the other hand is statically allocated and contains a number of fields that controls the process.

(in the first version of Erlang there was no parallelism and there could only be one process running at the time. In that version the sending process could write data directly on the receiving process' heap. With multi-core systems we use locks and queues to manage message copying accross process heaps. but this is out of scope to learn more check [this](https://blog.stenmans.org/theBeamBook/#_sending_messages_in_parallel))

Process communication is done through message passing. A process send is implemented so that a sending process copies the message from its own heap to the mailbox of the receiving process. In some cases(is suspended and no other process is trying to send a message) the message is directly copied to the receivers mailbox while in other cases message will end up in an `m-buf` After a GC the message will be moved into the heap. For more details check [here](https://blog.stenmans.org/theBeamBook/#_the_process_of_sending_a_message_to_a_process). m-bufs are varying number of heap fragments, a process can have multiple such m-bufs.

With the new *message_queue_data*
 flag introduced in Erlang 19 you can trade memory for execution time in a new way. If the receiving process is overloaded and holding on to the `main lock`
, it might be a good strategy to use the *off_heap*
 allocation in order to let the sending process quickly dump the message in an `m-buf`

## Process Dictionary

There is actually one more memory area in a process where Erlang terms can be stored, the *Process Dictionary*.

The *Process Dictionary* (PD) is a process local key-value store. One advantage with this is that all keys and values are stored on the heap and there is no copying as with send or an ETS table.

([ETS](https://elixirschool.com/en/lessons/storage/ets#overview-0) or Erlang Term Storage is a in-memory store for Elixir and Erlang objects that comes included. ETS is capable of storing large amounts of data and offers constant time data access. Tables in ETS are created and owned by individual processes. When an owner process terminates, its tables are destroyed)

```elixir
# Stores the given key-value pair in the process dictionary.
Process.put(:count, 1)
Process.put(:locale, "en")
```

<!-- livebook:{"output":true} -->

```
nil
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# Returns the value for the given key in the process dictionary
Process.get(:count)
```

<!-- livebook:{"output":true} -->

```
1
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# Returns all keys in the process dictionary
Process.get_keys()
```

<!-- livebook:{"output":true} -->

```
[:count, :evaluator_info, :"$initial_call", :"$ancestors", :ebin_path, :locale,
 :elixir_checker_info]
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# Deletes the given key from the process dictionary
Process.delete(:count)
```

<!-- livebook:{"output":true} -->

```
1
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# Returns all key-value pairs in the process dictionary.
Process.get()
```

<!-- livebook:{"output":true} -->

```
[
  evaluator_info: %{
    contexts: %{
      "64kfkhxoikw7ajmpamhkxzngr2xvrqip" => {"ioao5utb4ph6zd5mltvy5wpoccpgi6c4",
       #Macro.Env<
         aliases: [],
         context: nil,
         context_modules: [],
         file: "c:/Users/arpan/Documents/dev/async-elixir/processes.livemd#cell:64kfkhxoikw7ajmpamhkxzngr2xvrqip",
         function: nil,
         functions: [
           {Kernel,
            [
              !=: 2,
              !==: 2,
              *: 2,
              **: 2,
              +: 1,
              +: 2,
              ++: 2,
              -: 1,
              -: 2,
              --: 2,
              /: 2,
              <: 2,
              <=: 2,
              ==: 2,
              ===: 2,
              =~: 2,
              >: 2,
              >=: 2,
              abs: 1,
              apply: 2,
              apply: 3,
              binary_part: 3,
              binary_slice: 2,
              binary_slice: 3,
              bit_size: 1,
              byte_size: 1,
              ceil: 1,
              div: 2,
              elem: 2,
              exit: 1,
              floor: 1,
              function_exported?: 3,
              get_and_update_in: 3,
              get_in: 2,
              hd: 1,
              inspect: 1,
              ...
            ]}
         ],
         lexical_tracker: nil,
         line: 1,
         macro_aliases: [],
         macros: [
           {Kernel,
            [
              !: 1,
              &&: 2,
              ..: 0,
              ..: 2,
              ..//: 3,
              <>: 2,
              @: 1,
              alias!: 1,
              and: 2,
              binding: 0,
              binding: 1,
              dbg: 0,
              dbg: 1,
              dbg: 2,
              def: 1,
              def: 2,
              defdelegate: 2,
              defexception: 1,
              defguard: 1,
              defguardp: 1,
              defimpl: 2,
              defimpl: 3,
              defmacro: 1,
              defmacro: 2,
              defmacrop: 1,
              defmacrop: 2,
              defmodule: 2,
              defoverridable: 1,
              defp: 1,
              defp: 2,
              defprotocol: 2,
              defstruct: 1,
              ...
            ]}
         ],
         module: nil,
         requires: [],
         ...
       >},
      "67ncupnsfuxbpjgvke2vgtrkpct23jfm" => {"cajtlwqwrjxejcaqlgopeqht5bvifznu",
       #Macro.Env<
         aliases: [],
         context: nil,
         context_modules: [],
         file: "c:/Users/arpan/Documents/dev/async-elixir/processes.livemd#cell:67ncupnsfuxbpjgvke2vgtrkpct23jfm",
         function: nil,
         functions: [
           {Kernel,
            [
              !=: 2,
              !==: 2,
              *: 2,
              **: 2,
              +: 1,
              +: 2,
              ++: 2,
              -: 1,
              -: 2,
              --: 2,
              /: 2,
              <: 2,
              <=: 2,
              ==: 2,
              ===: 2,
              =~: 2,
              >: 2,
              >=: 2,
              abs: 1,
              apply: 2,
              apply: 3,
              binary_part: 3,
              binary_slice: 2,
              binary_slice: 3,
              bit_size: 1,
              byte_size: 1,
              ceil: 1,
              div: 2,
              elem: 2,
              exit: 1,
              floor: 1,
              function_exported?: 3,
              get_and_update_in: 3,
              get_in: 2,
              hd: 1,
              ...
            ]}
         ],
         lexical_tracker: nil,
         line: 1,
         macro_aliases: [],
         macros: [
           {Kernel,
            [
              !: 1,
              &&: 2,
              ..: 0,
              ..: 2,
              ..//: 3,
              <>: 2,
              @: 1,
              alias!: 1,
              and: 2,
              binding: 0,
              binding: 1,
              dbg: 0,
              dbg: 1,
              dbg: 2,
              def: 1,
              def: 2,
              defdelegate: 2,
              defexception: 1,
              defguard: 1,
              defguardp: 1,
              defimpl: 2,
              defimpl: 3,
              defmacro: 1,
              defmacro: 2,
              defmacrop: 1,
              defmacrop: 2,
              defmodule: 2,
              defoverridable: 1,
              defp: 1,
              defp: 2,
              defprotocol: 2,
              ...
            ]}
         ],
         module: nil,
         requires: [],
         ...
       >},
      "l7lp6athoy72a3u5d4whdrn4vqigthm5" => {"l6bxh7hubnjbvkarcjluolxoypdtxkw7",
       #Macro.Env<
         aliases: [],
         context: nil,
         context_modules: [],
         file: "c:/Users/arpan/Documents/dev/async-elixir/processes.livemd#cell:l7lp6athoy72a3u5d4whdrn4vqigthm5",
         function: nil,
         functions: [
           {Kernel,
            [
              !=: 2,
              !==: 2,
              *: 2,
              **: 2,
              +: 1,
              +: 2,
              ++: 2,
              -: 1,
              -: 2,
              --: 2,
              /: 2,
              <: 2,
              <=: 2,
              ==: 2,
              ===: 2,
              =~: 2,
              >: 2,
              >=: 2,
              abs: 1,
              apply: 2,
              apply: 3,
              binary_part: 3,
              binary_slice: 2,
              binary_slice: 3,
              bit_size: 1,
              byte_size: 1,
              ceil: 1,
              div: 2,
              elem: 2,
              exit: 1,
              floor: 1,
              function_exported?: 3,
              get_and_update_in: 3,
              get_in: 2,
              ...
            ]}
         ],
         lexical_tracker: nil,
         line: 1,
         macro_aliases: [],
         macros: [
           {Kernel,
            [
              !: 1,
              &&: 2,
              ..: 0,
              ..: 2,
              ..//: 3,
              <>: 2,
              @: 1,
              alias!: 1,
              and: 2,
              binding: 0,
              binding: 1,
              dbg: 0,
              dbg: 1,
              dbg: 2,
              def: 1,
              def: 2,
              defdelegate: 2,
              defexception: 1,
              defguard: 1,
              defguardp: 1,
              defimpl: 2,
              defimpl: 3,
              defmacro: 1,
              defmacro: 2,
              defmacrop: 1,
              defmacrop: 2,
              defmodule: 2,
              defoverridable: 1,
              defp: 1,
              defp: 2,
              ...
            ]}
         ],
         module: nil,
         requires: [],
         ...
       >},
      "setup" => {"phbthygryrf2ogkmjm3blfk6js7nea2a",
       #Macro.Env<
         aliases: [],
         context: nil,
         context_modules: [],
         file: "c:/Users/arpan/Documents/dev/async-elixir/processes.livemd#cell:setup",
         function: nil,
         functions: [
           {Kernel,
            [
              !=: 2,
              !==: 2,
              *: 2,
              **: 2,
              +: 1,
              +: 2,
              ++: 2,
              -: 1,
              -: 2,
              --: 2,
              /: 2,
              <: 2,
              <=: 2,
              ==: 2,
              ===: 2,
              =~: 2,
              >: 2,
              >=: 2,
              abs: 1,
              apply: 2,
              apply: 3,
              binary_part: 3,
              binary_slice: 2,
              binary_slice: 3,
              bit_size: 1,
              byte_size: 1,
              ceil: 1,
              div: 2,
              elem: 2,
              exit: 1,
              floor: 1,
              function_exported?: 3,
              get_and_update_in: 3,
              ...
            ]}
         ],
         lexical_tracker: nil,
         line: 1,
         macro_aliases: [],
         macros: [
           {Kernel,
            [
              !: 1,
              &&: 2,
              ..: 0,
              ..: 2,
              ..//: 3,
              <>: 2,
              @: 1,
              alias!: 1,
              and: 2,
              binding: 0,
              binding: 1,
              dbg: 0,
              dbg: 1,
              dbg: 2,
              def: 1,
              def: 2,
              defdelegate: 2,
              defexception: 1,
              defguard: 1,
              defguardp: 1,
              defimpl: 2,
              defimpl: 3,
              defmacro: 1,
              defmacro: 2,
              defmacrop: 1,
              defmacrop: 2,
              defmodule: 2,
              defoverridable: 1,
              defp: 1,
              ...
            ]}
         ],
         module: nil,
         requires: [],
         ...
       >},
      "upozi6chlbfh4lazaeymn6a7k4xgksae" => {"v26cddu64hs6kal32bezkzotrnx2w5im",
       #Macro.Env<
         aliases: [],
         context: nil,
         context_modules: [],
         file: "c:/Users/arpan/Documents/dev/async-elixir/processes.livemd#cell:upozi6chlbfh4lazaeymn6a7k4xgksae",
         function: nil,
         functions: [
           {Kernel,
            [
              !=: 2,
              !==: 2,
              *: 2,
              **: 2,
              +: 1,
              +: 2,
              ++: 2,
              -: 1,
              -: 2,
              --: 2,
              /: 2,
              <: 2,
              <=: 2,
              ==: 2,
              ===: 2,
              =~: 2,
              >: 2,
              >=: 2,
              abs: 1,
              apply: 2,
              apply: 3,
              binary_part: 3,
              binary_slice: 2,
              binary_slice: 3,
              bit_size: 1,
              byte_size: 1,
              ceil: 1,
              div: 2,
              elem: 2,
              exit: 1,
              floor: 1,
              function_exported?: 3,
              ...
            ]}
         ],
         lexical_tracker: nil,
         line: 1,
         macro_aliases: [],
         macros: [
           {Kernel,
            [
              !: 1,
              &&: 2,
              ..: 0,
              ..: 2,
              ..//: 3,
              <>: 2,
              @: 1,
              alias!: 1,
              and: 2,
              binding: 0,
              binding: 1,
              dbg: 0,
              dbg: 1,
              dbg: 2,
              def: 1,
              def: 2,
              defdelegate: 2,
              defexception: 1,
              defguard: 1,
              defguardp: 1,
              defimpl: 2,
              defimpl: 3,
              defmacro: 1,
              defmacro: 2,
              defmacrop: 1,
              defmacrop: 2,
              defmodule: 2,
              defoverridable: 1,
              ...
            ]}
         ],
         module: nil,
         requires: [],
         ...
       >},
      "velserxvjg2ofybi2rdcz5urtg7gghy2" => {"i5epqc5xlv2gfcaevcemhd5zpohf5tmr",
       #Macro.Env<
         aliases: [],
         context: nil,
         context_modules: [],
         file: "c:/Users/arpan/Documents/dev/async-elixir/processes.livemd#cell:velserxvjg2ofybi2rdcz5urtg7gghy2",
         function: nil,
         functions: [
           {Kernel,
            [
              !=: 2,
              !==: 2,
              *: 2,
              **: 2,
              +: 1,
              +: 2,
              ++: 2,
              -: 1,
              -: 2,
              --: 2,
              /: 2,
              <: 2,
              <=: 2,
              ==: 2,
              ===: 2,
              =~: 2,
              >: 2,
              >=: 2,
              abs: 1,
              apply: 2,
              apply: 3,
              binary_part: 3,
              binary_slice: 2,
              binary_slice: 3,
              bit_size: 1,
              byte_size: 1,
              ceil: 1,
              div: 2,
              elem: 2,
              exit: 1,
              floor: 1,
              ...
            ]}
         ],
         lexical_tracker: nil,
         line: 1,
         macro_aliases: [],
         macros: [
           {Kernel,
            [
              !: 1,
              &&: 2,
              ..: 0,
              ..: 2,
              ..//: 3,
              <>: 2,
              @: 1,
              alias!: 1,
              and: 2,
              binding: 0,
              binding: 1,
              dbg: 0,
              dbg: 1,
              dbg: 2,
              def: 1,
              def: 2,
              defdelegate: 2,
              defexception: 1,
              defguard: 1,
              defguardp: 1,
              defimpl: 2,
              defimpl: 3,
              defmacro: 1,
              defmacro: 2,
              defmacrop: 1,
              defmacrop: 2,
              defmodule: 2,
              ...
            ]}
         ],
         module: nil,
         requires: [],
         ...
       >},
      "wp3y63pybp5komgzriwdl5ph3glj2acr" => {"n2oonm3ncezu7cl32zohiq622oix3be7",
       #Macro.Env<
         aliases: [],
         context: nil,
         context_modules: [],
         file: "c:/Users/arpan/Documents/dev/async-elixir/processes.livemd#cell:wp3y63pybp5komgzriwdl5ph3glj2acr",
         function: nil,
         functions: [
           {Kernel,
            [
              !=: 2,
              !==: 2,
              *: 2,
              **: 2,
              +: 1,
              +: 2,
              ++: 2,
              -: 1,
              -: 2,
              --: 2,
              /: 2,
              <: 2,
              <=: 2,
              ==: 2,
              ===: 2,
              =~: 2,
              >: 2,
              >=: 2,
              abs: 1,
              apply: 2,
              apply: 3,
              binary_part: 3,
              binary_slice: 2,
              binary_slice: 3,
              bit_size: 1,
              byte_size: 1,
              ceil: 1,
              div: 2,
              elem: 2,
              exit: 1,
              ...
            ]}
         ],
         lexical_tracker: nil,
         line: 1,
         macro_aliases: [],
         macros: [
           {Kernel,
            [
              !: 1,
              &&: 2,
              ..: 0,
              ..: 2,
              ..//: 3,
              <>: 2,
              @: 1,
              alias!: 1,
              and: 2,
              binding: 0,
              binding: 1,
              dbg: 0,
              dbg: 1,
              dbg: 2,
              def: 1,
              def: 2,
              defdelegate: 2,
              defexception: 1,
              defguard: 1,
              defguardp: 1,
              defimpl: 2,
              defimpl: 3,
              defmacro: 1,
              defmacro: 2,
              defmacrop: 1,
              defmacrop: 2,
              ...
            ]}
         ],
         module: nil,
         requires: [],
         ...
       >}
    },
    initial_context: {"de7bgljnqxfevzjo7nukcp776cnhjtaj",
     #Macro.Env<
       aliases: [],
       context: nil,
       context_modules: [],
       file: "nofile",
       function: nil,
       functions: [
         {Kernel,
          [
            !=: 2,
            !==: 2,
            *: 2,
            **: 2,
            +: 1,
            +: 2,
            ++: 2,
            -: 1,
            -: 2,
            --: 2,
            /: 2,
            <: 2,
            <=: 2,
            ==: 2,
            ===: 2,
            =~: 2,
            >: 2,
            >=: 2,
            abs: 1,
            apply: 2,
            apply: 3,
            binary_part: 3,
            binary_slice: 2,
            binary_slice: 3,
            bit_size: 1,
            byte_size: 1,
            ceil: 1,
            div: 2,
            elem: 2,
            exit: 1,
            floor: 1,
            function_exported?: 3,
            get_and_update_in: 3,
            get_in: 2,
            hd: 1,
            inspect: 1,
            ...
          ]}
       ],
       lexical_tracker: nil,
       line: 1,
       macro_aliases: [],
       macros: [
         {Kernel,
          [
            !: 1,
            &&: 2,
            ..: 0,
            ..: 2,
            ..//: 3,
            <>: 2,
            @: 1,
            alias!: 1,
            and: 2,
            binding: 0,
            binding: 1,
            dbg: 0,
            dbg: 1,
            dbg: 2,
            def: 1,
            def: 2,
            defdelegate: 2,
            defexception: 1,
            defguard: 1,
            defguardp: 1,
            defimpl: 2,
            defimpl: 3,
            defmacro: 1,
            defmacro: 2,
            defmacrop: 1,
            defmacrop: 2,
            defmodule: 2,
            defoverridable: 1,
            defp: 1,
            defp: 2,
            defprotocol: 2,
            defstruct: 1,
            ...
          ]}
       ],
       module: nil,
       requires: [Application, Kernel, Kernel.Typespec],
       ...
     >}
  },
  "$initial_call": {Livebook.Runtime.Evaluator, :init, 1},
  "$ancestors": [#PID<0.131.0>, #PID<0.130.0>, #PID<0.126.0>, Livebook.Runtime.ErlDist.NodeManager,
   #PID<0.124.0>],
  ebin_path: "C:\\Users\\arpan\\AppData\\Local\\Temp/livebook_runtime/nnakju664abw6wyeiqsvf6jgiclnadmb/ebin",
  locale: "en",
  elixir_checker_info: {#PID<0.136.0>, nil}
]
```

## Process Basics

The most fundamental way to create processes in Elixir is by using the [spawn/1](https://hexdocs.pm/elixir/1.12/Kernel.html#spawn/1), [receive/1](https://hexdocs.pm/elixir/1.12/Kernel.SpecialForms.html#receive/1), and [send/2](https://hexdocs.pm/elixir/1.12/Kernel.html#send/2) functions. They enable us to spawn a process, wait for messages, and send messages to a process, respectively.

Many higher-level abstractions, such as Task, GenServer, and Agent, are built on top of these primitive functions.

These functions are part of the [Kernel](https://hexdocs.pm/elixir/1.12/Kernel.html) module and are automatically imported, allowing us to call them directly without needing to use the Kernel. prefix.

Let's take a look at some examples of their usage...

```elixir
# Spawn a process, by passing it a function to execute.
# spawn/1 returns the pid (process identifier) of the spawed process
pid = spawn(fn -> IO.puts("Hello world") end)

# Once the process has finished excuting it will exit
Process.alive?(pid) |> IO.inspect()

# Sleep for 100ms to wait for process to exit
:timer.sleep(100)

Process.alive?(pid)
```

<!-- livebook:{"output":true} -->

```
true
Hello world
```

<!-- livebook:{"output":true} -->

```
false
```

To exchange messages between processes in Elixir, you can use the send/2 and receive/1 functions.

When a process uses send/2 to send a message, it doesn't block - instead, the message is placed in the recipient's mailbox, and the sending process continues.

On the other hand, when a process uses receive/1, it blocks until a matching message is found in its mailbox. The receive/1 function searches the mailbox for a message that matches any of the given patterns.

receive/1 supports guards and multiple clauses, such as case/2.

Let's look at an example of a process sending a message to itself.

```elixir
# Get the pid of the current process
self_pid = self()

# Send a message to the current process
send(self_pid, :ping)

# Check messages in mailbox without consuming them
Process.info(self_pid, :messages) |> IO.inspect(label: "Messages in mailbox")

# Recieve the message waiting in mailbox
receive do
  :ping -> IO.puts(:pong)
end

# Check messages in mailbox again
Process.info(self_pid, :messages) |> IO.inspect(label: "Messages in mailbox")
```

<!-- livebook:{"output":true} -->

```
Messages in mailbox: {:messages, [:ping]}
pong
Messages in mailbox: {:messages, []}
```

<!-- livebook:{"output":true} -->

```
{:messages, []}
```

An optional after clause can be given in case the message was not received after the given timeout period, specified in milliseconds.
(If timeout `0` is given then the message is expected to be already present in the mailbox.)

```elixir
receive do
  {:message, message} when message in [:start, :stop] -> IO.puts(message)
  _ -> IO.puts(:stderr, "Unexpected message received")
after
  1000 -> IO.puts(:stderr, "Timeout, no message in 1 seconds")
end
```

<!-- livebook:{"output":true} -->

```
Timeout, no message in1 seconds
```

<!-- livebook:{"output":true} -->

```
:ok
```

In the elixir IEx shell, we have a helper function [flush/0](https://hexdocs.pm/iex/main/IEx.Helpers.html#flush/0) that flushes or consumes and prints all the messages in the mailbox of the shell process.

```elixir
send(self(), :hello)

Process.info(self_pid, :messages) |> IO.inspect(label: "Messages in mailbox before flush")

# In the iex shell we wont have to use the `IEx.Helpers,` prefix since these helpers functions are imported automatically
IEx.Helpers.flush()

Process.info(self_pid, :messages) |> IO.inspect(label: "Messages in mailbox after flush")
```

<!-- livebook:{"output":true} -->

```
Messages in mailbox before flush: {:messages, [:hello]}
:hello
Messages in mailbox after flush: {:messages, []}
```

<!-- livebook:{"output":true} -->

```
{:messages, []}
```

## Process Linking

## Common functions to work with processes

## Group Leader

In Erlang, every process belongs to a process group, and each group has a group leader. The group leader is responsible for handling I/O for the processes in its group. When a process is spawned, it inherits the same group leader as its parent process. At system start-up, the init process is both its own group leader and the group leader of all processes.

The Erlang VM models I/O devices as processes, which enables different nodes in the same network to exchange file processes and read/write files between nodes. The group leader can be configured per process and is used in different situations. For example, when executing code in a remote terminal, it ensures that messages from a remote node are redirected and printed in the terminal that triggered the request.

The main responsibility of the group leader is to collect I/O output from all processes in its group and pass it to or from the underlying system. It essentially owns the standard input, standard output, and standard error channels on behalf of the group.

When a file is opened using `File.open/2`, it returns a tuple like `{:ok, io_device}`, where `io_device` is the PID of the process that handles the file. This process monitors the process that opened the file (the owner process), and if the owner process terminates, the file is closed, and the process itself terminates too.

When you call `IO.write(pid, binary)`, the IO module sends a message to the process identified by pid with the desired operation, such as :put_chars. 
The message has the following structure: `{:io_request, <pid>, <reference>, {:put_chars, :unicode, "hello"}}`.

When you write to :stdio, you are actually sending a message to the group leader, which writes to the standard-output file descriptor. 
Therefore, these three code snippets are equivalent:

```
IO.puts "hello"
IO.puts :stdio, "hello"
IO.puts Process.group_leader, "hello"
```

To understand this better let see some examples

Suppose we have two Erlang nodes named "node1" and "node2". 
You can create two `iex` shells for this like

```
iex --sname node1@localhost
iex --sname node2@localhost
```

(Note: If you want to send messages between nodes on different networks, we need to start the named nodes with a shared cookie)

If we execute the following code in the iex shell of node1:

```
Node.spawn_link(:node2@localhost, fn ->
  IO.puts("I will be executed on node2 but printed on node1 since the group leader is node1")
end)
```

The output of the IO.puts operation will be sent to the group leader, which in this case is node1. 
Therefore, the output will be printed on node1's standard output stream, even though the process that performed the operation is running on node2.

On the other hand, if we specify the device PID as the `:init` process on node2, the output will be seen on node2's standard output stream:

```
Node.spawn_link(:node2@localhost, fn ->
  init_process_pid = Process.whereis(:init)

  IO.puts(
    init_process_pid,
    "I will be executed on node2 and printed on node2 since the device ID passed was node2's init process"
  )
end)
```

Finally, we can also set the group leader of a process explicitly by calling `Process.group_leader/2`. 
In the following example, we set the group leader of the process running on node2 to node2's `:init` process:

```
Node.spawn_link(:node2@localhost, fn ->
  init_process_pid = Process.whereis(:init)
  Process.group_leader(self(), init_process_pid)

  IO.puts(
    "I will be executed on node2 and printed on node2 since the group leader is set to node2's init process"
  )
end)
```

In this case, the output of the `IO.puts` operation will be sent to node2's `:init` process, which is the new group leader of the process. 
Therefore, the output will be printed on node2's standard output stream.

## Resources

* https://elixir-lang.org/getting-started/processes.html#:~:text=In Elixir%2C all code runs,distributed and fault-tolerant programs.
* https://blog.stenmans.org/theBeamBook/#CH-Processes
* https://hexdocs.pm/elixir/1.12/Process.html
* https://eddwardo.github.io/posts/links-in-elixir/
* https://www.erlang-solutions.com/blog/understanding-processes-for-elixir-developers/
* Group Leader
  * https://www.erlang.org/doc/man/erlang.html#group_leader-0
  * https://stackoverflow.com/questions/36318766/what-is-a-group-leader
  * https://rokobasilisk.gitbooks.io/elixir-getting-started/content/io_and_the_file_system/processes_and_group_leaders.html
  * https://elixirschool.com/en/lessons/advanced/otp_distribution#a-note-on-io-and-nodes-2
